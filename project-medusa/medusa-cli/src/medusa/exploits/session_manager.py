"""
Session Manager
Manages active exploitation sessions
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
import logging
import json
from pathlib import Path


class SessionManager:
    """
    Manages active exploitation sessions

    Features:
    - Track active sessions
    - Session metadata
    - Session persistence
    - Command history
    """

    def __init__(self, rpc_client=None, session_dir: Optional[Path] = None):
        """
        Initialize Session Manager

        Args:
            rpc_client: Metasploit RPC client
            session_dir: Directory to store session data
        """
        self.rpc = rpc_client
        self.logger = logging.getLogger(__name__)

        self.session_dir = session_dir or Path.home() / ".medusa" / "sessions"
        self.session_dir.mkdir(parents=True, exist_ok=True)

        self.sessions: Dict[str, Dict[str, Any]] = {}
        self._load_sessions()

    def list_sessions(self) -> List[Dict[str, Any]]:
        """
        List all active sessions

        Returns:
            List of session dictionaries
        """
        if self.rpc:
            # Get latest from MSF
            msf_sessions = self.rpc.list_sessions()

            # Update local cache
            for session in msf_sessions:
                session_id = str(session["id"])
                if session_id not in self.sessions:
                    self.sessions[session_id] = {
                        "id": session_id,
                        "created_at": datetime.now().isoformat(),
                        "commands": [],
                        **session
                    }

        return list(self.sessions.values())

    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """
        Get session by ID

        Args:
            session_id: Session ID

        Returns:
            Session dictionary or None
        """
        return self.sessions.get(str(session_id))

    def add_session(
        self,
        session_id: str,
        metadata: Dict[str, Any]
    ):
        """
        Add a new session

        Args:
            session_id: Session ID
            metadata: Session metadata
        """
        self.sessions[str(session_id)] = {
            "id": str(session_id),
            "created_at": datetime.now().isoformat(),
            "commands": [],
            **metadata
        }

        self._save_sessions()

    def execute_command(
        self,
        session_id: str,
        command: str
    ) -> str:
        """
        Execute command in session

        Args:
            session_id: Session ID
            command: Command to execute

        Returns:
            Command output
        """
        if not self.rpc:
            raise RuntimeError("No RPC client configured")

        session_id = str(session_id)

        if session_id not in self.sessions:
            raise ValueError(f"Session {session_id} not found")

        # Execute via RPC
        output = self.rpc.interact_session(session_id, command)

        # Record in history
        self.sessions[session_id]["commands"].append({
            "command": command,
            "output": output,
            "timestamp": datetime.now().isoformat()
        })

        self._save_sessions()

        return output

    def stop_session(self, session_id: str) -> bool:
        """
        Stop/kill a session

        Args:
            session_id: Session ID

        Returns:
            True if stopped successfully
        """
        session_id = str(session_id)

        if not self.rpc:
            # Just remove from local cache
            if session_id in self.sessions:
                del self.sessions[session_id]
                self._save_sessions()
                return True
            return False

        # Stop via RPC
        success = self.rpc.stop_session(session_id)

        if success and session_id in self.sessions:
            del self.sessions[session_id]
            self._save_sessions()

        return success

    def get_command_history(self, session_id: str) -> List[Dict[str, Any]]:
        """
        Get command history for a session

        Args:
            session_id: Session ID

        Returns:
            List of command dictionaries
        """
        session = self.get_session(str(session_id))
        if not session:
            return []

        return session.get("commands", [])

    def export_session(
        self,
        session_id: str,
        output_path: Path
    ) -> bool:
        """
        Export session data to file

        Args:
            session_id: Session ID
            output_path: Output file path

        Returns:
            True if exported successfully
        """
        session = self.get_session(str(session_id))
        if not session:
            return False

        try:
            with open(output_path, 'w') as f:
                json.dump(session, f, indent=2)

            self.logger.info(f"Session {session_id} exported to {output_path}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to export session: {e}")
            return False

    def _load_sessions(self):
        """Load sessions from disk"""
        session_file = self.session_dir / "sessions.json"

        if not session_file.exists():
            return

        try:
            with open(session_file) as f:
                self.sessions = json.load(f)

            self.logger.info(f"Loaded {len(self.sessions)} sessions from disk")

        except Exception as e:
            self.logger.warning(f"Failed to load sessions: {e}")

    def _save_sessions(self):
        """Save sessions to disk"""
        session_file = self.session_dir / "sessions.json"

        try:
            with open(session_file, 'w') as f:
                json.dump(self.sessions, f, indent=2)

        except Exception as e:
            self.logger.error(f"Failed to save sessions: {e}")
