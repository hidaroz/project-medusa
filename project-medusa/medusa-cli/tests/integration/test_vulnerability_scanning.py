"""
Integration tests for vulnerability scanning with SQLMap and Nikto
Tests the scan_for_vulnerabilities method with real tools
"""

import pytest
import asyncio
from medusa.client import MedusaClient
from medusa.tools.sql_injection import SQLMapScanner
from medusa.tools.web_vuln import NiktoScanner


@pytest.mark.integration
@pytest.mark.asyncio
async def test_client_has_vulnerability_tools():
    """Test that client initializes with vulnerability scanning tools"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    # Check that tools are initialized
    assert hasattr(client, "sqlmap")
    assert hasattr(client, "nikto")
    assert client.sqlmap is not None
    assert client.nikto is not None

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_scan_for_vulnerabilities_method_exists():
    """Test that scan_for_vulnerabilities method exists"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    assert hasattr(client, "scan_for_vulnerabilities")
    assert callable(client.scan_for_vulnerabilities)

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
@pytest.mark.skipif(
    not (SQLMapScanner().is_available() and NiktoScanner().is_available()),
    reason="SQLMap or Nikto not installed"
)
async def test_scan_for_vulnerabilities_execution():
    """Test vulnerability scanning execution with real tools"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    # Run vulnerability scan on example.com (safe, public site)
    result = await client.scan_for_vulnerabilities("http://example.com")

    # Check that result has the REAL_TOOLS flag
    assert result.get("mode") == "REAL_TOOLS", "Client should use real tools"

    # Check result structure
    assert "phase" in result
    assert result["phase"] == "vulnerability_scanning"
    assert "findings" in result
    assert "executed_actions" in result
    assert "severity_breakdown" in result
    assert "duration" in result

    # Check severity breakdown
    breakdown = result["severity_breakdown"]
    assert "critical" in breakdown
    assert "high" in breakdown
    assert "medium" in breakdown
    assert "low" in breakdown

    print(f"\nVulnerability scanning results:")
    print(f"Mode: {result.get('mode')}")
    print(f"Findings count: {result.get('findings_count')}")
    print(f"Duration: {result.get('duration'):.2f}s")
    print(f"Severity breakdown: {breakdown}")

    # Check executed actions
    actions = result["executed_actions"]
    tool_names = [action.get("tool") for action in actions]

    print(f"Tools executed: {set(tool_names)}")

    # Verify real tools were attempted
    assert "nikto" in tool_names or "sqlmap" in tool_names, \
        "At least one vulnerability scanning tool should have been executed"

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_identify_sql_injection_targets():
    """Test SQL injection target identification"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    # Create mock enumeration findings
    enumeration_findings = [
        {
            "type": "api_endpoint",
            "url": "http://example.com/api/users",
            "status_code": 200
        },
        {
            "type": "api_endpoint",
            "url": "http://example.com/api/products",
            "status_code": 200
        },
        {
            "type": "web_service",
            "url": "http://example.com",
            "status_code": 200
        }
    ]

    targets = client._identify_sql_injection_targets(
        "http://example.com",
        enumeration_findings
    )

    assert len(targets) > 0
    assert "http://example.com" in targets

    # Should include API endpoints with parameters
    api_targets = [t for t in targets if "/api/" in t]
    assert len(api_targets) > 0

    print(f"\nIdentified {len(targets)} SQL injection targets:")
    for target in targets[:5]:
        print(f"  - {target}")

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
@pytest.mark.skipif(not NiktoScanner().is_available(), reason="Nikto not installed")
async def test_nikto_only_scan():
    """Test vulnerability scanning when only Nikto is available"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    # Override sqlmap to simulate it not being available
    original_sqlmap = client.sqlmap
    client.sqlmap.is_available = lambda: False

    result = await client.scan_for_vulnerabilities("http://example.com")

    # Should still work with just Nikto
    assert result.get("mode") == "REAL_TOOLS"
    assert "findings" in result

    actions = result["executed_actions"]
    nikto_actions = [a for a in actions if a.get("tool") == "nikto"]
    assert len(nikto_actions) > 0, "Nikto should have been executed"

    print(f"\nNikto-only scan found {result['findings_count']} issues")

    # Restore
    client.sqlmap = original_sqlmap

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_full_pentesting_workflow():
    """Test complete workflow: recon -> enum -> vuln scan"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    target = "example.com"

    # Step 1: Reconnaissance
    print("\n=== Phase 1: Reconnaissance ===")
    recon_result = await client.perform_reconnaissance(target)
    assert recon_result.get("mode") == "REAL_TOOLS"
    recon_findings = recon_result.get("findings", [])
    print(f"Reconnaissance found {len(recon_findings)} items")

    # Step 2: Enumeration
    print("\n=== Phase 2: Enumeration ===")
    enum_result = await client.enumerate_services(
        target,
        reconnaissance_findings=recon_findings
    )
    assert enum_result.get("mode") == "REAL_TOOLS"
    enum_findings = enum_result.get("findings", [])
    print(f"Enumeration found {len(enum_findings)} items")

    # Step 3: Vulnerability Scanning
    print("\n=== Phase 3: Vulnerability Scanning ===")
    vuln_result = await client.scan_for_vulnerabilities(
        f"http://{target}",
        enumeration_findings=enum_findings
    )
    assert vuln_result.get("mode") == "REAL_TOOLS"
    vuln_findings = vuln_result.get("findings", [])
    print(f"Vulnerability scan found {len(vuln_findings)} issues")

    # Summary
    print("\n=== Summary ===")
    total_findings = len(recon_findings) + len(enum_findings) + len(vuln_findings)
    print(f"Total findings across all phases: {total_findings}")
    print(f"Reconnaissance: {len(recon_findings)}")
    print(f"Enumeration: {len(enum_findings)}")
    print(f"Vulnerabilities: {len(vuln_findings)}")

    if vuln_findings:
        print("\nVulnerability severity breakdown:")
        for severity in ["critical", "high", "medium", "low"]:
            count = len([f for f in vuln_findings if f.get("severity") == severity])
            if count > 0:
                print(f"  {severity.capitalize()}: {count}")

    await client.close()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_vulnerability_findings_structure():
    """Test that vulnerability findings have correct structure"""
    client = MedusaClient(
        base_url="http://localhost:8000",
        api_key="test",
        llm_config={"mock_mode": True}
    )

    result = await client.scan_for_vulnerabilities("http://example.com")

    # Check that each finding has required fields
    for finding in result.get("findings", []):
        assert "type" in finding, "Finding must have type"
        assert "severity" in finding, "Finding must have severity"
        assert finding["severity"] in ["critical", "high", "medium", "low", "info"]
        assert "confidence" in finding, "Finding must have confidence"

        # Optional but recommended fields
        if "title" in finding:
            assert isinstance(finding["title"], str)
        if "description" in finding:
            assert isinstance(finding["description"], str)

    print(f"\nAll {len(result.get('findings', []))} findings have valid structure")

    await client.close()


if __name__ == "__main__":
    # Run basic test
    asyncio.run(test_scan_for_vulnerabilities_execution())
